# 输入提示问题 - Typeahead Problem


## 题目
Typeahead/Auto Complete 一般用于输入提示/自动补全，这类问题在系统设计中也十分常见，一般typeahead有两种，一种是所有用户的typeahead提示都一样，是最近热门搜索词，另一种是根据用户自己的历史记录给出相应推荐，当然，有时候还会有混合型的。 这类问题在某些部分和[Top K 问题](top-k-problem.md) 相似，都是需要在大量数据中选出热门的搜索词条，对结果同样也不需要非常高的精度。不过Typeahead还有个读频繁的，在数据存储和分区方面会有不

## 总结
读写频繁，不用完全精确选出提示内容（精确程度需要和面试官确认）。
* 数据查询（用户每次搜索通过查询服务返回提示）
* 数据搜集（可以通过采样、缓存等方式优化） 
* 数据聚合（一致性哈希分配机器，桶，堆和队列进行统计）


## 需求分析 
### 直接需求
* 用户输入的时候给出提示
* 提示的词条为5个（10个也行，一般为一个很小的数字），提示词条根据所有用户的搜索行为来选择，比如当前大量用户搜索apple，则输入app应该提示出apple。
* 不需要根据每个用户行为定制结果，即所有用户的提示都一样。
* 用户完成输入以后才显示结果（而不是根据用户输入不断展示结果 Google Instant Search）
* （进阶）让最新的热门词汇排在前面（比如 #a 今天被搜100次，昨天10次，#b昨天被搜200次，今天1次，尽管b搜索次数更过，我们还是要把#a排在前面）
* （进阶）需要做拼写检查，找出相近词的提示（比如color/colour， 或者recruiter/recrutier)


### 隐含需求
以下内容需要跟面试官确认。
* 读写频繁 (read & write heavy)
* 延迟要低，不能等用户都输入完成了才显示之前的提示
* 数据不要求有非常高的实时性（可以有适当延迟，比如几分钟，但不能是一天或者几个小时）
* 数据不要求有非常高的精确性（只需要知道热搜前几名是什么即可）
* 高可用性（一般系统都需要）

## 估算 （Estimation）
* DAU: 1 Billion, 20% of user post everyday <br>
* Write QPS: 1B * 20% / 86400 ~ 200M/100K ~ 2k QPS, peak QPS ~ 6k<br>
* Read QPS: 假设为写的10%， 200 QPS <br>
* Data storage: 假设 word (20 Bytes), count(8 Bytes) , 200M/day * 28 Bytes ~ 200*30MB ~ 6GB / day <br>

数据量大，服务用户多，肯定需要分布式系统来处理。

## 服务设计
整个系统可以分为两大部分，一部分是写服务，主要接受用户查询请求，并做出统计。另一部分是读服务，根据用户输入，每次给用户提示。如果只有单台机器，我们可以在机器中划分出以下几个服务。

### 搜索服务（Query/search service)
* 采集用户输入词汇，根据用户输入返回特定搜索结果.
* 在用户输入词汇的时候，在用户完成输入之前，给用户提示。

### 数据搜集（Data Collection）服务
监听搜索服务的输入，每当用户完成输入的时候，搜集用户输入的关键词，进行分析统计，类似于Map-Reduce中的 Map。这一步可以是异步操作，这样不会影响搜索服务的效率。

### 数据聚合（Data Aggregation）、存储(Data Storage) 服务
#### 数据存储

#### 数据聚合
##### 选项一：类似Top K 问题
将搜集到的数据聚合统计，类似于Map-Reduce中的reduce。我们用哈希表`Map<String, Long>` 存放每个关键词被用户搜索的次数。同时我们将时间划分为多个桶(bucket)放入队列，桶的大小根据精度来确定，typeahead可以选择小时，或者天为单位。当某个词被用户搜索的时候，我们把该话题放入当前（队尾）时间所对应的桶里面。每过了一个单位时间，我们将更早（队首）的桶移除队列，被移除的桶里面存有多个词的搜索次数，我们在Map中找到对应词，减去相应次数。同时把队尾桶中的统计数据加入Map中。

这样统计的缺点在于，最新的热搜权重不够，比如 #a 今天被搜100次，昨天10次，#b昨天被搜200次，今天1次，尽管b搜索次数更过，我们还是要把#a排在前面。

##### 选项二：使用加权移动平均（exponential moving average)
我们使用EMA给最近的热搜更高的权重。 比如我们要统计10天EMA。
```
10日EMA的算式为：（分母=10+1）
EMA（10）= 前一日EMA(10) * 9/11＋今日搜索次数×2/11
```
我们在系统中维持每个词的EMA，同时统计当前



## Scale up

### 处理长尾效应
选项一，通过sampling去掉出现比较少的词


## 其他
#### 如果需求是每个用户结果不一样？

#### 客户端缓存       



## 参考资料
* [Facebook Typeahead Search Tech Talk (6/15/2010)](https://www.facebook.com/Engineering/videos/432864835468)